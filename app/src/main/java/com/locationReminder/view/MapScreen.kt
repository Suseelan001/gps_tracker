package com.locationReminder.viewimport android.Manifestimport android.app.Activityimport android.content.Contextimport android.content.pm.PackageManagerimport android.location.Geocoderimport android.widget.Toastimport androidx.activity.compose.BackHandlerimport androidx.activity.compose.rememberLauncherForActivityResultimport androidx.activity.result.contract.ActivityResultContractsimport androidx.annotation.RequiresPermissionimport androidx.compose.foundation.backgroundimport androidx.compose.foundation.layout.Boximport androidx.compose.runtime.Composableimport androidx.compose.foundation.layout.Columnimport androidx.compose.foundation.layout.Rowimport androidx.compose.foundation.layout.Spacerimport androidx.compose.foundation.layout.fillMaxSizeimport androidx.compose.foundation.layout.fillMaxWidthimport androidx.compose.foundation.layout.heightimport androidx.compose.foundation.layout.paddingimport androidx.compose.foundation.shape.RoundedCornerShapeimport androidx.compose.material.icons.Iconsimport androidx.compose.material3.Iconimport androidx.compose.material3.Textimport androidx.compose.runtime.*import androidx.compose.ui.Alignmentimport androidx.compose.ui.unit.dpimport androidx.compose.material.icons.filled.Searchimport androidx.compose.material3.Buttonimport androidx.compose.material3.ButtonDefaultsimport androidx.compose.material3.ExperimentalMaterial3Apiimport androidx.compose.material3.IconButtonimport androidx.compose.material3.Sliderimport androidx.compose.material3.TextFieldimport androidx.compose.material3.TextFieldDefaultsimport androidx.compose.runtime.LaunchedEffectimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateOfimport androidx.compose.runtime.rememberimport androidx.compose.runtime.saveable.rememberSaveableimport androidx.compose.ui.Modifierimport androidx.compose.ui.draw.shadowimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.platform.LocalContextimport androidx.core.app.ActivityCompatimport androidx.navigation.NavHostControllerimport com.google.android.gms.location.FusedLocationProviderClientimport com.google.android.gms.location.LocationServicesimport com.google.android.gms.maps.CameraUpdateFactoryimport com.google.android.gms.maps.model.CameraPositionimport com.google.android.gms.maps.model.LatLngimport com.google.android.libraries.places.api.model.AutocompletePredictionimport com.google.android.libraries.places.api.net.FindAutocompletePredictionsRequestimport com.google.maps.android.compose.Circleimport com.google.maps.android.compose.GoogleMapimport com.google.maps.android.compose.MapPropertiesimport com.google.maps.android.compose.MapUiSettingsimport com.google.maps.android.compose.Markerimport com.google.maps.android.compose.MarkerStateimport com.google.maps.android.compose.rememberCameraPositionStateimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.ExperimentalCoroutinesApiimport kotlinx.coroutines.launchimport kotlinx.coroutines.suspendCancellableCoroutineimport kotlinx.coroutines.withContextimport java.util.Localeimport kotlin.coroutines.resumeWithExceptionimport androidx.compose.foundation.lazy.itemsimport androidx.compose.material3.SliderDefaultsimport androidx.compose.ui.unit.spimport androidx.core.view.WindowCompatimport com.google.android.gms.tasks.Taskimport com.locationReminder.viewModel.AddLocationViewModelimport androidx.compose.runtime.DisposableEffectimport androidx.compose.foundation.clickableimport androidx.compose.foundation.layout.Arrangementimport androidx.compose.foundation.layout.sizeimport androidx.compose.foundation.layout.widthimport androidx.compose.foundation.layout.wrapContentHeightimport androidx.compose.foundation.layout.wrapContentSizeimport androidx.compose.foundation.lazy.LazyColumnimport androidx.compose.foundation.rememberScrollStateimport androidx.compose.foundation.verticalScrollimport androidx.compose.material3.BottomSheetScaffoldimport androidx.compose.material3.Checkboximport androidx.compose.material3.CheckboxDefaultsimport androidx.compose.material3.CircularProgressIndicatorimport androidx.compose.material3.FloatingActionButtonimport androidx.compose.material3.Switchimport androidx.compose.material3.SwitchDefaultsimport androidx.compose.runtime.livedata.observeAsStateimport androidx.compose.ui.draw.scaleimport androidx.compose.ui.graphics.toArgbimport androidx.compose.ui.platform.LocalViewimport androidx.compose.ui.res.painterResourceimport androidx.compose.ui.zIndeximport androidx.core.view.WindowInsetsControllerCompatimport com.locationReminder.ui.theme.Hex1C1C1Cimport com.locationReminder.Rimport com.locationReminder.reponseModel.LocationDetailimport com.locationReminder.ui.theme.HexFFFFFFimport com.locationReminder.ui.theme.Hexeef267import com.locationReminder.view.appNavigation.NavigationRouteimport com.locationReminder.viewModel.AddContactViewModelimport com.locationReminder.viewModel.PlacesClientManagerimport kotlinx.coroutines.Jobimport kotlinx.coroutines.delayimport com.locationReminder.viewModel.AddSettingsViewModelimport com.locationReminder.viewModel.SharedPreferenceVMimport kotlinx.coroutines.CoroutineScope@Composable fun MapScreen(    navHostController: NavHostController,    type: String, itemId: String,categoryId: String,categoryTitle: String,    addLocationViewModel: AddLocationViewModel,    addContactViewModel: AddContactViewModel,    addSettingsViewModel:AddSettingsViewModel,    sharedPreferenceVM: SharedPreferenceVM) {    SetStatusBarStyle()    var showMap by remember { mutableStateOf(false) }    LaunchedEffect(Unit) {        delay(200)        showMap = true    }    if (showMap) {        MapHomeScreen(navHostController, type,itemId,categoryId,categoryTitle,addLocationViewModel,addContactViewModel,addSettingsViewModel,sharedPreferenceVM)    } }@OptIn(ExperimentalMaterial3Api::class)@Composablefun MapHomeScreen(    navHostController: NavHostController,    type: String, itemId: String,categoryId: String,    categoryTitle: String,    addLocationViewModel: AddLocationViewModel,    addContactViewModel: AddContactViewModel,    addSettingsViewModel:AddSettingsViewModel,    sharedPreferenceVM: SharedPreferenceVM){    val context = LocalContext.current    var currentLocation by remember { mutableStateOf<Pair<Double, Double>?>(null) }    var isLoading by remember { mutableStateOf(true) }    var markerPosition by remember { mutableStateOf<LatLng?>(null) }    var circleRadius by remember { mutableFloatStateOf(100f) }    var maximumRadius by remember { mutableStateOf("2000") }    val isSearching = remember { mutableStateOf(false) }    var address by remember { mutableStateOf("") }    val searchQuery = rememberSaveable { mutableStateOf("") }    val searchResults = remember { mutableStateListOf<AutocompletePrediction>() }    val noResultsFound = remember { mutableStateOf(false) }    val expanded = remember { mutableStateOf(false) }    var title by remember { mutableStateOf("") }    var vibrationOn by remember { mutableStateOf(true) }    var enableContactCheckBox by remember { mutableStateOf(false) }    var  sendNotification by remember { mutableStateOf(false) }    var showDistance by remember { mutableStateOf("") }    val coroutineScope = rememberCoroutineScope()    val debounceJob = remember { mutableStateOf<Job?>(null) }    val placesClient = remember {        PlacesClientManager.getClient(context)    }    val searchBarVisible = remember { mutableStateOf(false) }    val allRecords by addContactViewModel.getAllRecord().observeAsState(emptyList())    if (allRecords.isNotEmpty()){        enableContactCheckBox=true    }    DisposableEffect(Unit) {        onDispose {            PlacesClientManager.shutdown()        }    }    val settingsRecord by addSettingsViewModel.getAllRecord().observeAsState()    LaunchedEffect(itemId, settingsRecord) {        if (itemId.isNotEmpty()) {            val locationRecord = addLocationViewModel.getSingleRecord(itemId.toInt())            title = locationRecord.title            circleRadius = locationRecord.radius            vibrationOn=locationRecord.vibration            sendNotification=locationRecord.sendNotification            markerPosition = LatLng(locationRecord.lat, locationRecord.lng)            coroutineScope.launch(Dispatchers.IO) {                val addr = getAddressFromLatLng(context, LatLng(locationRecord.lat, locationRecord.lng))                withContext(Dispatchers.Main) {                    address = addr                    searchBarVisible.value = false                }            }            settingsRecord?.let {                maximumRadius = it.maximumRadius            }        } else if (settingsRecord != null) {            maximumRadius = settingsRecord!!.maximumRadius            showDistance = settingsRecord!!.unit            circleRadius = when (type) {                "Exit" -> settingsRecord!!.exitRadius.toFloat()                "Entry" -> settingsRecord!!.entryRadius.toFloat()                else -> 100f            }        }    }    LaunchedEffect(searchQuery.value) {        debounceJob.value?.cancel()        if (searchQuery.value.isNotEmpty()) {            debounceJob.value = coroutineScope.launch {                delay(500)                isSearching.value = true                noResultsFound.value = false // reset state                try {                    val request = FindAutocompletePredictionsRequest.builder()                        .setQuery(searchQuery.value)                        .setCountries(listOf("IN"))                        .build()                    val response = placesClient.findAutocompletePredictions(request).await()                    searchResults.clear()                    searchResults.addAll(response.autocompletePredictions)                    noResultsFound.value = searchResults.isEmpty()                    expanded.value = searchResults.isNotEmpty() || noResultsFound.value                } catch (_: Exception) {                    noResultsFound.value = true                } finally {                    isSearching.value = false                }            }        }    }    LaunchedEffect(searchBarVisible.value) {        if (searchBarVisible.value) {            delay(100)        }    }    BackHandler(enabled = true) {        navHostController.popBackStack()    }    val requestPermissionLauncher = rememberLauncherForActivityResult(        ActivityResultContracts.RequestPermission()    ) { isGranted ->        if (isGranted) {            getCurrentLocation(context) { location ->                currentLocation = location                isLoading = false            }        } else {            isLoading = false        }    }    val cameraPositionState = rememberCameraPositionState {        position = CameraPosition.fromLatLngZoom(LatLng(0.0, 0.0), 10f)    }    LaunchedEffect(Unit) {        when {            ActivityCompat.checkSelfPermission(                context, Manifest.permission.ACCESS_FINE_LOCATION            ) == PackageManager.PERMISSION_GRANTED -> {                getCurrentLocation(context) { location ->                    currentLocation = location                    isLoading = false                }            }            else -> requestPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)        }    }    LaunchedEffect(currentLocation) {        if (itemId.isEmpty()){            currentLocation?.let {                cameraPositionState.position = CameraPosition.fromLatLngZoom(                    LatLng(it.first, it.second), 15f                )            }        }    }    BottomSheetScaffold(        sheetContainerColor=Hex1C1C1C,        sheetPeekHeight = if (address!= "") 180.dp else 0.dp,        sheetContent = {            if (address!= "") {                Column(                    modifier = Modifier                        .fillMaxWidth()                        .wrapContentHeight()                        .verticalScroll(rememberScrollState())                ) {                    Column(                        modifier = Modifier                            .fillMaxWidth()                            .background(Color(0xFF1C1C1C))                            .padding(start = 20.dp, end = 20.dp, bottom = 20.dp)                    ) {                        Text("Radius", color = Color.White, fontSize = 16.sp)                        Row(                            modifier = Modifier                                .fillMaxWidth()                                .padding(vertical = 12.dp),                            verticalAlignment = Alignment.CenterVertically                        ) {                            Slider(                                value = circleRadius,                                onValueChange = { circleRadius = it },                                valueRange = 1f..maximumRadius.toFloat(),                                colors = SliderDefaults.colors(                                    thumbColor = Hexeef267,                                    activeTrackColor = Hexeef267                                ),                                modifier = Modifier.weight(1f)                            )                            Spacer(modifier = Modifier.width(12.dp))                            val selectedUnit = DistanceUnit.fromString(showDistance)                            val distanceText = formatDistance(circleRadius, selectedUnit)                            Text(                                text = distanceText,                                color = Hexeef267,                                fontSize = 14.sp                            )                        }                        Spacer(Modifier.height(12.dp))                        Text("Title", color = Color.White, fontSize = 16.sp)                        TextField(                            value = title,                            onValueChange = { title = it },                            placeholder = { Text("Title Here", color = Color.Gray) },                            colors = TextFieldDefaults.colors(                                focusedTextColor = Color.White,                                unfocusedTextColor = Color.White,                                focusedIndicatorColor = Color.Gray,                                unfocusedIndicatorColor = Color.DarkGray,                                cursorColor = Color.Gray,                                unfocusedContainerColor = Color.Transparent,                                focusedContainerColor = Color.Transparent,                            ),                            singleLine = true,                            modifier = Modifier.fillMaxWidth()                        )                        Spacer(Modifier.height(16.dp))                        Text("Address", color = Color.White, fontSize = 16.sp)                        Spacer(Modifier.height(12.dp))                        Text(address, color = Color.Gray, fontSize = 16.sp)                        Spacer(Modifier.height(12.dp))                        Row(                            verticalAlignment = Alignment.CenterVertically,                            horizontalArrangement = Arrangement.SpaceBetween,                            modifier = Modifier                                .fillMaxWidth()                                .padding(vertical = 8.dp)                        ) {                            Text("Vibration", color = Color.White, fontSize = 16.sp)                            Switch(                                checked = vibrationOn,                                onCheckedChange = { newState -> vibrationOn = newState },                                modifier = Modifier.scale(0.75f),                                colors = SwitchDefaults.colors(                                    uncheckedThumbColor = Color(0xFFEEF267),                                    checkedThumbColor = Color.White,                                    uncheckedTrackColor = Color.White,                                    checkedTrackColor = Color(0xFFEEF267),                                    uncheckedBorderColor = Color.Transparent,                                    checkedBorderColor = Color.Transparent                                )                            )                        }                        if (type=="Exit" && enableContactCheckBox==true && sharedPreferenceVM.isUserLoggedIn()){                            Row(                                verticalAlignment = Alignment.CenterVertically,                                horizontalArrangement = Arrangement.SpaceBetween,                                modifier = Modifier                                    .fillMaxWidth()                                    .padding(vertical = 8.dp)                            ) {                                Text(text = "Send notification to emergency contact", color = HexFFFFFF)                                Checkbox(                                    checked = sendNotification,                                    onCheckedChange = { sendNotification = it },                                    colors = CheckboxDefaults.colors(                                        checkedColor = Hexeef267,                                        checkmarkColor = Color.Black,                                        uncheckedColor = Hexeef267,                                    )                                )                            }                        }                        Spacer(Modifier.height(12.dp))                          Button(                            onClick = {                                if (title == ""){                                    title="Undefined title"                                }                                    markerPosition?.let {                                        // currentLocation?.let { loc ->                                        val locationDetail = LocationDetail(                                            id = itemId.toIntOrNull() ?: 0,                                            title = title,                                            address = address,                                            entryType = type,                                            radius = circleRadius,                                            lat = it.latitude,                                            lng = it.longitude,                                            currentStatus = true,                                            sendNotification = sendNotification,                                            vibration = vibrationOn                                        )                                        if (type == "Marker") {                                            if (itemId.isNotEmpty()) {                                                addLocationViewModel.editMarker(                                                    "eq.$itemId",                                                    title,                                                    address,                                                    type,                                                    circleRadius,                                                    it.latitude,                                                    it.longitude,                                                    true,                                                    sendNotification,                                                    vibrationOn,                                                    categoryId,                                                    categoryTitle                                                )                                                Toast.makeText(                                                    context,                                                    "Location updated successfully",                                                    Toast.LENGTH_SHORT                                                ).show()                                            } else {                                                addLocationViewModel.addMarkerList(                                                    title,                                                    address,                                                    type,                                                    circleRadius,                                                    it.latitude,                                                    it.longitude,                                                    true,                                                    sendNotification,                                                    vibrationOn,                                                    categoryId,                                                    categoryTitle                                                )                                                Toast.makeText(                                                    context,                                                    "Location saved successfully",                                                    Toast.LENGTH_SHORT                                                ).show()                                            }                                        } else {                                            val updatedDetail = if (type == "ImportedMarker") {                                                locationDetail.copy(category_id = categoryId)                                            } else {                                                locationDetail                                            }                                            if (itemId.isNotEmpty()) {                                                addLocationViewModel.updateRecord(updatedDetail)                                                Toast.makeText(                                                    context,                                                    "Location updated successfully",                                                    Toast.LENGTH_SHORT                                                ).show()                                            } else {                                                addLocationViewModel.insertAccount(updatedDetail)                                                Toast.makeText(                                                    context,                                                    "Location saved successfully",                                                    Toast.LENGTH_SHORT                                                ).show()                                            }                                        }                                        when (type) {                                            "Entry" -> {                                                navHostController.navigate(NavigationRoute.HOMESCREEN.path) {                                                    popUpTo(NavigationRoute.HOMESCREEN.path) {                                                        inclusive = true                                                    }                                                }                                            }                                            "Exit" -> {                                                navHostController.navigate(NavigationRoute.LEADSSCREEN.path) {                                                    popUpTo(NavigationRoute.LEADSSCREEN.path) {                                                        inclusive = true                                                    }                                                }                                            }                                            "Marker" -> {                                                CoroutineScope(Dispatchers.Main).launch {                                                    delay(500)                                                    navHostController.popBackStack()                                                }                                            }                                            "ImportedMarker" -> {                                                navHostController.popBackStack()                                            }                                        }                                        //}                                    }                            },                            modifier = Modifier                                .fillMaxWidth()                                .height(55.dp),                            colors = ButtonDefaults.buttonColors(                                containerColor = Hexeef267 ,                                contentColor = Color.Black                            ),                            shape = RoundedCornerShape(50)                        ) {                            Text("SAVE", fontSize = 18.sp)                        }                        Spacer(Modifier.height(40.dp))                    }                }            } }    ) {        Box(modifier = Modifier.fillMaxSize()) {            Column(modifier = Modifier.fillMaxSize()) {                Box(modifier = Modifier.fillMaxSize()) {                    if (type == "Exit") {                        val currentLatitude = currentLocation?.first ?: 0.0                        val currentLongitude = currentLocation?.second ?: 0.0                        if (currentLatitude != 0.0 && currentLongitude != 0.0) {                            if (itemId.isNotEmpty()) {                                LaunchedEffect(markerPosition) {                                    markerPosition?.let {                                        cameraPositionState.animate(                                            update = CameraUpdateFactory.newLatLngZoom(it, 15f)                                        )                                    }                                }                            }                            GoogleMap(                                    modifier = Modifier                                        .fillMaxSize()                                        .padding(bottom = 16.dp)                                        .zIndex(0f),                                    cameraPositionState = cameraPositionState,                                    properties = MapProperties(                                        isMyLocationEnabled = true                                    ),                                    uiSettings = MapUiSettings(                                        zoomControlsEnabled = false,                                        myLocationButtonEnabled = false                                    ),                                    onMapClick = { latLng ->                                        if (type.isNotEmpty()) {                                            markerPosition = latLng                                            coroutineScope.launch(Dispatchers.IO) {                                                val addr = getAddressFromLatLng(context, latLng)                                                withContext(Dispatchers.Main) {                                                    address = addr                                                    searchBarVisible.value=false                                                }                                            }                                            coroutineScope.launch {                                                cameraPositionState.animate(                                                    update = CameraUpdateFactory.newLatLngZoom(                                                        latLng,                                                        15f                                                    )                                                )                                            }                                        }                                    }                                ) {                                    markerPosition?.let {                                        Marker(                                            state = MarkerState(position = it)                                        )                                        Circle(                                            center = it,                                            radius = circleRadius.toDouble(),                                            strokeColor = Color.Blue,                                            strokeWidth = 2f,                                            fillColor = Color(0x330000FF)                                        )                                    }                                    if (itemId.isEmpty()){                                        LaunchedEffect(currentLatitude, currentLongitude) {                                            val addr = withContext(Dispatchers.IO) {                                                getAddressFromLatLng(                                                    context,                                                    LatLng(currentLatitude, currentLongitude)                                                )                                            }                                            address = addr                                            searchBarVisible.value=false                                            markerPosition = LatLng(currentLatitude, currentLongitude)                                        }                                    }                                }                                Column(                                    modifier = Modifier                                        .align(Alignment.BottomEnd)                                        .padding(end = 16.dp, bottom = 180.dp),                                    verticalArrangement = Arrangement.spacedBy(5.dp)                                ) {                                    FloatingActionButton(                                        onClick = {                                            coroutineScope.launch {                                                val fusedLocationClient =                                                    LocationServices.getFusedLocationProviderClient(                                                        context                                                    )                                                val location = fusedLocationClient.lastLocation.await()                                                location?.let {                                                    val currentLatLng =                                                        LatLng(it.latitude, it.longitude)                                                    cameraPositionState.animate(                                                        CameraUpdateFactory.newLatLngZoom(                                                            currentLatLng,                                                            15f                                                        )                                                    )                                                }                                            }                                        },                                        containerColor = Color.White,                                        contentColor = Color.Black,                                    ) {                                        Icon(                                            painter = painterResource(id = R.drawable.focus_current_location),                                            contentDescription = "Go to current location"                                        )                                    }                                    FloatingActionButton(                                        onClick = {                                            val currentZoom = cameraPositionState.position.zoom                                            coroutineScope.launch {                                                cameraPositionState.animate(                                                    CameraUpdateFactory.zoomTo(currentZoom + 1f)                                                )                                            }                                        },                                        containerColor = Color.White,                                        contentColor = Color.Black,                                    ) {                                        Icon(                                            painter = painterResource(id = R.drawable.plus),                                            contentDescription = "Zoom In"                                        )                                    }                                    FloatingActionButton(                                        onClick = {                                            val currentZoom = cameraPositionState.position.zoom                                            coroutineScope.launch {                                                cameraPositionState.animate(                                                    CameraUpdateFactory.zoomTo(currentZoom - 1f)                                                )                                            }                                        },                                        containerColor = Color.White,                                        contentColor = Color.Black,                                    ) {                                        Icon(                                            painter = painterResource(id = R.drawable.minus),                                            contentDescription = "Zoom Out",                                            tint = Color.Black,                                            modifier = Modifier.padding(3.dp)                                        )                                    }                                }                        }                    } else {                        Box(Modifier.fillMaxSize()) {                            if (itemId.isNotEmpty()){                                LaunchedEffect(markerPosition) {                                    markerPosition?.let {                                        cameraPositionState.animate(                                            update = CameraUpdateFactory.newLatLngZoom(it, 15f)                                        )                                    }                                }                            }else{                                LaunchedEffect(Unit) {                                    searchBarVisible.value=true                                }                            }                            GoogleMap(                                        modifier = Modifier.matchParentSize(),                                cameraPositionState = cameraPositionState,                                properties = MapProperties(isMyLocationEnabled = true),                                uiSettings = MapUiSettings(                                    zoomControlsEnabled = false,                                    myLocationButtonEnabled = false                                ),                                onMapClick = { latLng ->                                    searchBarVisible.value=false                                    if (type.isNotEmpty()) {                                        markerPosition = latLng                                        coroutineScope.launch(Dispatchers.IO) {                                            val addr = getAddressFromLatLng(context, latLng)                                            withContext(Dispatchers.Main) {                                                address = addr                                            }                                        }                                        coroutineScope.launch {                                            cameraPositionState.animate(                                                update = CameraUpdateFactory.newLatLngZoom(                                                    latLng,                                                    15f                                                )                                            )                                        }                                    }                                }                            ) {                                markerPosition?.let {                                    Marker(                                        state = MarkerState(position = it)                                    )                                    Circle(                                        center = it,                                        radius = circleRadius.toDouble(),                                        strokeColor = Color.Blue,                                        strokeWidth = 2f,                                        fillColor = Color(0x330000FF)                                    )                                }                            }                            Column(                                modifier = Modifier                                    .align(Alignment.BottomEnd)                                    .padding(end = 16.dp, bottom = 180.dp),                                verticalArrangement = Arrangement.spacedBy(5.dp)                            ) {                                FloatingActionButton(                                    onClick = {                                        coroutineScope.launch {                                            val fusedLocationClient =                                                LocationServices.getFusedLocationProviderClient(                                                    context                                                )                                            val location = fusedLocationClient.lastLocation.await()                                            location?.let {                                                val currentLatLng =                                                    LatLng(it.latitude, it.longitude)                                                cameraPositionState.animate(                                                    CameraUpdateFactory.newLatLngZoom(                                                        currentLatLng,                                                        15f                                                    )                                                )                                            }                                        }                                    },                                    containerColor = Color.White,                                    contentColor = Color.Black,                                ) {                                    Icon(                                        painter = painterResource(id = R.drawable.focus_current_location),                                        contentDescription = "Go to current location"                                    )                                }                                FloatingActionButton(                                    onClick = {                                        val currentZoom = cameraPositionState.position.zoom                                        coroutineScope.launch {                                            cameraPositionState.animate(                                                CameraUpdateFactory.zoomTo(currentZoom + 1f)                                            )                                        }                                    },                                    containerColor = Color.White,                                    contentColor = Color.Black,                                ) {                                    Icon(                                        painter = painterResource(id = R.drawable.plus),                                        contentDescription = "Zoom In"                                    )                                }                                FloatingActionButton(                                    onClick = {                                        val currentZoom = cameraPositionState.position.zoom                                        coroutineScope.launch {                                            cameraPositionState.animate(                                                CameraUpdateFactory.zoomTo(currentZoom - 1f)                                            )                                        }                                    },                                    containerColor = Color.White,                                    contentColor = Color.Black,                                ) {                                    Icon(                                        painter = painterResource(id = R.drawable.minus),                                        contentDescription = "Zoom Out",                                        tint = Color.Black,                                        modifier = Modifier.padding(3.dp)                                    )                                }                            }                        }                    }                    if (type.isNotEmpty()) {                        if (searchBarVisible.value) {                            Box(                                modifier = Modifier                                    .fillMaxWidth()                                    .padding(top = 48.dp, start = 16.dp, end = 16.dp)                                    .shadow(8.dp, shape = RoundedCornerShape(32.dp))                                    .background(Color.Black, shape = RoundedCornerShape(32.dp))                                    .padding(horizontal = 12.dp, vertical = 6.dp)                            ) {                                Column {                                    Row(                                        verticalAlignment = Alignment.CenterVertically,                                        modifier = Modifier.fillMaxWidth()                                    ) {                                        Box(modifier = Modifier.weight(1f)) {                                            TextField(                                                value = searchQuery.value,                                                onValueChange = {                                                    searchQuery.value = it                                                    if (it.isEmpty()) {                                                        expanded.value = false                                                        searchResults.clear()                                                    }                                                },                                                placeholder = {                                                    Text("Search here", color = Color.LightGray)                                                },                                                singleLine = true,                                                modifier = Modifier.fillMaxWidth(),                                                colors = TextFieldDefaults.colors(                                                    focusedTextColor = Color.White,                                                    unfocusedTextColor = Color.White,                                                    cursorColor = Color.White,                                                    focusedContainerColor = Color.Transparent,                                                    unfocusedContainerColor = Color.Transparent,                                                    focusedIndicatorColor = Color.Transparent,                                                    unfocusedIndicatorColor = Color.Transparent                                                ),                                                leadingIcon = {                                                    IconButton(onClick = {}) {                                                        Icon(                                                            imageVector = Icons.Default.Search,                                                            contentDescription = "Search",                                                            tint = Color.White                                                        )                                                    }                                                },                                                trailingIcon = {                                                    if (isSearching.value) {                                                        CircularProgressIndicator(                                                            modifier = Modifier                                                                .size(20.dp)                                                                .padding(end = 8.dp),                                                            color = Color.White,                                                            strokeWidth = 2.dp                                                        )                                                    } else if (searchQuery.value.isNotEmpty()) {                                                        IconButton(onClick = {                                                            searchQuery.value = ""                                                            expanded.value = false                                                            searchResults.clear()                                                        }) {                                                            Icon(                                                                painter = painterResource(id = R.drawable.cancel),                                                                contentDescription = "cancel",                                                                tint = Color.White                                                            )                                                        }                                                    }                                                }                                            )                                        }                                    }                                    if (expanded.value) {                                        Spacer(modifier = Modifier                                            .height(5.dp)                                            .background(Color.White))                                            Box(                                                modifier = Modifier                                                    .fillMaxWidth()                                                    .padding(horizontal = 16.dp, vertical = 8.dp)                                                    .background(Color.Black)                                            ) {                                                if (noResultsFound.value) {                                                    Text(                                                        text = "No results found",                                                        color = Color.White,                                                        modifier = Modifier                                                            .fillMaxWidth()                                                            .padding(                                                                horizontal = 16.dp,                                                                vertical = 12.dp                                                            )                                                    )                                                } else {                                                    LazyColumn(                                                        modifier = Modifier                                                            .fillMaxWidth()                                                            .background(Color.Black)                                                            .padding(vertical = 8.dp)                                                    ) {                                                        items(searchResults) { prediction ->                                                            Text(                                                                text = prediction.getFullText(null).toString(),                                                                color = Color.White,                                                                modifier = Modifier                                                                    .fillMaxWidth()                                                                    .clickable {                                                                        expanded.value = false                                                                        searchQuery.value =                                                                            prediction.getFullText(                                                                                null                                                                            ).toString()                                                                        getLatLngFromAddress(                                                                            context,                                                                            searchQuery.value                                                                        ) { latLng ->                                                                            markerPosition = latLng                                                                            address =                                                                                getAddressFromLatLng(                                                                                    context,                                                                                    latLng                                                                                )                                                                            cameraPositionState.position =                                                                                CameraPosition.fromLatLngZoom(                                                                                    latLng,                                                                                    15f                                                                                )                                                                            searchBarVisible.value =                                                                                false                                                                        }                                                                        searchQuery.value = ""                                                                        searchResults.clear()                                                                    }                                                                    .padding(                                                                        horizontal = 16.dp,                                                                        vertical = 12.dp                                                                    )                                                            )                                                        }                                                    }                                                }                                            }                                        }                                }                            }                        } else                        {                            Box(                                modifier = Modifier                                    .padding(top = 48.dp, end = 16.dp)                                    .wrapContentSize()                                    .shadow(8.dp, shape = RoundedCornerShape(32.dp))                                    .background(Color.Black, shape = RoundedCornerShape(32.dp))                                    .padding(6.dp)                                    .align(Alignment.TopEnd)                            ) {                                IconButton(onClick = { searchBarVisible.value = true }) {                                    Icon(                                        imageVector = Icons.Default.Search,                                        contentDescription = "Search",                                        tint = Color.White                                    )                                }                            }                        }                }                    }            }        }    }}fun getAddressFromLatLng(context: Context, latLng: LatLng): String {    val geocoder = Geocoder(context, Locale.getDefault())    return try {        val addresses = geocoder.getFromLocation(latLng.latitude, latLng.longitude, 1)        if (addresses?.isNotEmpty() == true) {            addresses[0].getAddressLine(0)        } else {            "Address not found"        }    } catch (_: Exception) {        "Unable to fetch address"    }}fun getLatLngFromAddress(context: Context, address: String, onResult: (LatLng) -> Unit) {    val geocoder = Geocoder(context, Locale.getDefault())    try {        val addresses = geocoder.getFromLocationName(address, 1)        if (addresses?.isNotEmpty() == true) {            val location = addresses[0]            onResult(LatLng(location.latitude, location.longitude))        }    } catch (e: Exception) {        e.printStackTrace()    }}@RequiresPermission(allOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])fun getCurrentLocation(    context: Context,    onLocationReceived: (Pair<Double, Double>) -> Unit) {    val fusedLocationClient: FusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(context)    fusedLocationClient.lastLocation.addOnSuccessListener { location ->        location?.let {            onLocationReceived(Pair(it.latitude, it.longitude))        }    }}@OptIn(ExperimentalCoroutinesApi::class)suspend fun <T> Task<T>.await(): T {    return suspendCancellableCoroutine { cont ->        addOnCompleteListener {            if (it.isSuccessful) {                cont.resume(it.result, null)            } else {                cont.resumeWithException(it.exception ?: Exception("Unknown Task exception"))            }        }    }}sealed class DistanceUnit(    val labelSmall: String,    val labelLarge: String,    val thresholdInMeters: Float,    val convertToSmall: (Float) -> Float,    val convertToLarge: (Float) -> Float){    object MeterKilometer : DistanceUnit("m", "km", 1000f, { it }, { it / 1000f })    object KilometerMile : DistanceUnit("km", "mi", 1609.344f, { it / 1000f }, { it / 1609.344f })    object YardMile : DistanceUnit("yd", "mi", (1760 * 0.9144f), { it / 0.9144f }, { it / 1609.344f })    object FootMeter : DistanceUnit("ft", "m", 3.28084f, { it * 3.28084f }, { it })    companion object {        fun fromString(name: String): DistanceUnit = when(name) {            "Meters/Kilometers" -> MeterKilometer            "Kilometers/Mile" -> KilometerMile            "Yard/Mile" -> YardMile            "Foot/Meters" -> FootMeter            else -> MeterKilometer        }    }}fun formatDistance(distanceInMeters: Float, unit: DistanceUnit): String {    return if (distanceInMeters < unit.thresholdInMeters) {        val smallValue = unit.convertToSmall(distanceInMeters)        "%.1f %s".format(smallValue, unit.labelSmall)    } else {        val largeValue = unit.convertToLarge(distanceInMeters)        "%.1f %s".format(largeValue, unit.labelLarge)    }}@Composablefun SetStatusBarStyle() {    val context = LocalContext.current    val view = LocalView.current    val activity = context as Activity    SideEffect {        val window = activity.window        window.statusBarColor = Color.Transparent.toArgb()        WindowCompat.setDecorFitsSystemWindows(window, false)        val insetsController = WindowInsetsControllerCompat(window, view)        insetsController.isAppearanceLightStatusBars = false    }}